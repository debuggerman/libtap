Very early start.

Usage:

    #include "tap.h", and link against libtap.so

Start by calling one of the plan_* functions:

    plan_no_plan()                        /* you have no test plan, or */
    plan_skip_all("Skipping because...")  /* all tests will be skipped, or */
    plan_tests(42);                       /* you will run 42 tests */

plan_no_plan() indicates that you don't know how many tests you're going
to run.  This is possible, but a bad idea.

plan_skip_all(msg) indicates that you are going to skip all the tests in
this file.  'msg' should indicate the reason for skipping (e.g., a database
connection could not be made).

plan_tests(n) indicates that you are going to run 'n' tests.  Running any
fewer or any more is treated as a failure.

Then you have one of ok() or ok1() at your disposal.  ok()'s first parameter
is the code to test.  The second parameter is the test name.  This is a 
printf()like format string, and the third and subsequent parameters should
fill out any values in the string.

    ok(a_func() == 0, "test name");
    ok(some_func(i), "some_func(%d)", i);

ok1() is for situations where the code to test is sufficiently 
self-documenting that you don't need to provide a test name.

    ok1(code to test); /* test name is automatically the same as the code */

E.g.,

    ok(1 == 1, "1 equals one"); /* PRINT: ok 1 - 1 equals 1 */
    ok1(1 == 2);                /* PRINT: not ok 2 - 1 == 2 */

You also have pass(test_name, ...) and fail(test_name, ...).  test_name is a 
printf()'like string. 

From the Test::More documentation:

    Sometimes you just want to say that the tests have passed.  Usually
    the case is you've got some complicated condition that is difficult
    to wedge into an ok().  In this case, you can simply use pass() (to
    declare the test ok) or fail (for not ok).

    Use these very, very, very sparingly.

These are synonyms for ok(1, test_name, ...) and ok(0, test_name, ...).

Sets of tests can be skipped.  Ordinarily you would do this because
the test can't be run in this particular testing environment.

For example, suppose some tests should be run as root.  If the test is
not being run as root then the tests should be skipped.  In this 
implementation, skipped tests are flagged as being ok, with a special
message indicating that they were skipped.

    skip(n, msg, ...);

will produce output for 'n' lines of skipped tests.  The output message
is 'msg', and is printf()like.  It is your responsibility to ensure that
'n' is correct for the number of tests to skip.

This is normally implemented with a "do { ... } while(0);" loop, with a 
"continue;" immediately after the skip() call.  This ensures that there
are no additional side effects from the skipped tests.

    do {
        if(getuid() != 0) {
            skip(1, "Test only makes sense as root");
            continue;
        }

        ok(do_something_as_root() == 0, "do_something_as_root() worked");
    } while(0);

Two macros, skip_start and skip_end can handle some of this for you.  The
above example could be re-written:

    skip_start(getuid() != 0, 1, "Test only makes sense as root");

    ok(do_something_as_root() == 0, "do_something_as_root() worked");

    skip_end;	/* It's a macro, no parentheses... */

Sets of tests can be flagged as being 'TODO'.  These are tests that you
expect to fail, probably because you haven't fixed a bug, or finished
a new feature yet.  These tests will still be run, but with additional
output that indicates that they are expected to fail.  Should a test start
to succeed unexpectedly, tools like prove(1) will indicate this, and you
can move the test out of the todo block.  This is much more useful than
simply commenting (or "#ifdef 0 ... #endif") the tests.

    todo_start("dwim() not implemented yet");

    ok(dwim(), "Did what the user wanted");

    todo_end();

Should dwim() ever start succeeding you'll know about it as soon as you
run the tests.  Note that *unlike* skip_*, additional code between 
todo_start() and todo_end() *is* executed.

From the Test::More documentation:

   When do I use SKIP vs. TODO?
       If it's something the user might not be able to do, use SKIP.  This
       includes optional modules that aren't installed, running under
       an OS that doesn't have some feature (like fork() or symlinks),
       or maybe you need an Internet connection and one isn't
       available.

       If it's something the programmer hasn't done yet, use TODO.
       This is for any code you haven't written yet, or bugs you have
       yet to fix, but want to put tests in your testing script
       (always a good idea).

You also have diag(), which takes a printf() style format string and related
arguments, and sends the output to stderr as a test comment.  diag() adds
the necessary trailing "\n" for you.

    diag("Expected return code 0, got return code %d", rcode);

Finally, there's exit_status(), which returns an int suitable for use
when return'ing from main(), or calling exit().  You should always do one
of:

    return exit_status();
    exit(exit_status());

As appropriate.  

SIDE EFFECTS

Ideally running the tests should have no side effects on the behaviour
of the application you're testing.  However, it's not always possible to
avoid them.

 * stdout is set to unbuffered mode after calling any of the plan_*()
   functions.
