Very early start.

Usage:

    #include "tap.h", and link against libtap.so

Start by calling one of the plan_* functions:

    plan_no_plan()                        /* you have no test plan, or */
    plan_skip_all("Skipping because...")  /* all tests will be skipped, or */
    plan_tests(42);                       /* you will run 42 tests */

plan_no_plan() indicates that you don't know how many tests you're going
to run.  This is possible, but a bad idea.

plan_skip_all(msg) indicates that you are going to skip all the tests in
this file.  'msg' should indicate the reason for skipping (e.g., a database
connection could not be made).

plan_tests(n) indicates that you are going to run 'n' tests.  Running any
fewer or any more is treated as a failure.

Then you have one of ok() or ok1() at your disposal.  ok()'s first parameter
is the code to test.  The second parameter is the test name.  This is a 
printf()like format string, and the third and subsequent parameters should
fill out any values in the string.

    ok(a_func() == 0, "test name");
    ok(some_func(i), "some_func(%d)", i);

ok1() is for situations where the code to test is sufficiently 
self-documenting that you don't need to provide a test name.

    ok1(code to test); /* test name is automatically the same as the code */

E.g.,

    ok(1 == 1, "1 equals one"); /* PRINT: ok 1 - 1 equals 1 */
    ok1(1 == 2);                /* PRINT: not ok 2 - 1 == 2 */

You also have pass(test_name, ...) and fail(test_name, ...).  test_name is a 
printf()'like string. 

From the Test::More documentation:

    Sometimes you just want to say that the tests have passed.  Usually
    the case is you've got some complicated condition that is difficult
    to wedge into an ok().  In this case, you can simply use pass() (to
    declare the test ok) or fail (for not ok).

    Use these very, very, very sparingly.

These are synonyms for ok(1, test_name, ...) and ok(0, test_name, ...).

Sets of tests can be skipped.  Ordinarily you would do this because
the test can't be run in this particular testing environment.

For example, suppose some tests should be run as root.  If the test is
not being run as root then the tests should be skipped.  In this 
implementation, skipped tests are flagged as being ok, with a special
message indicating that they were skipped.

    skip(n, msg, ...);

will produce output for 'n' lines of skipped tests.  The output message
is 'msg', and is printf()like.  It is your responsibility to ensure that
'n' is correct for the number of tests to skip.

This is normally implemented with a "do { ... } while(0);" loop, with a 
"continue;" immediately after the skip() call.  This ensures that there
are no additional side effects from the skipped tests.

    do {
        if(getuid() != 0) {
            skip(1, "Test only makes sense as root");
            continue;
        }

        ok(do_something_as_root() == 0, "do_something_as_root() worked");
    } while(0);

Two macros, skip_start and skip_end can handle some of this for you.  The
above example could be re-written:

    skip_start(getuid() != 0, 1, "Test only makes sense as root");

    ok(do_something_as_root() == 0, "do_something_as_root() worked");

    skip_end;	/* It's a macro, no parentheses... */

You also have diag(), which takes a printf() style format string and related
arguments, and sends the output to stderr as a test comment.  diag() adds
the necessary trailing "\n" for you.

    diag("Expected return code 0, got return code %d", rcode);

Finally, there's exit_status(), which returns an int suitable for use
when return'ing from main(), or calling exit().  You should always do one
of:

    return exit_status();
    exit(exit_status());

As appropriate.  

SIDE EFFECTS

Ideally running the tests should have no side effects on the behaviour
of the application you're testing.  However, it's not always possible to
avoid them.

 * stdout is set to unbuffered mode after calling any of the plan_*()
   functions.
